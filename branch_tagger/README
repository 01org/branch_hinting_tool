Prerequisite:
You must have python installed.

Contents:
- global_var.py
- tag_file.py
- apply_on_folder.py
- run_class.py
- states_imp.py
- fsm.py
- state.py
- helpers.py
- README

WHAT IT DOES?
branch_tagger takes C/C++  source code files and tags all the conditional instructions --if, while, for-- with
the comment /*branch_type branch boolean_operator_type*/.
branch_type = {if, for, while}
boolean_operator_type = {&&, ||}

Since "gcov" counts how many times a line of code has been executed, then all conditional instructions with multiple
conditions must be separated with one simple condition per line.
If there are multiple simple conditions inside a conditional instruction, branch_tagger will eliminate all line endings,
then it will split the line before the binary operator(&& or ||) and it will tag each condition until the last closing
parenthesis of the conditional instruction. If one line comments --//one line comment-- appear inside the conditional
instruction, that instruction will not be tagged.

Example: if /* multi-line
            comment */ (a && b || /* comment
                        inside branch*/ c) a = b
          -------->
          if /* multi-line             comment */ (a /*if branch &&*/
          && b /*if branch ||*/
          || /* comment                         inside branch*/ c) /*if branch &&*/a = b


USAGE:
The script will make a copy of the folder which contains the files you want to modify(a.k.a. the .c and .h files which
will have the if, for and while branches tagged) and it will replace the original ones with the tagged files.


IMPLEMENTATION
A finite state machine handles the various states the source code from C/C++ file traverses.
The conditional instruction is called context. The context begins when an if, for, while is found and it ends when
the last closing parenthesis of the conditional instruction is found. Example of context: if (a && b)

OutContext represents the interior of a comment, a string or everything else which is not inside a context.
This delimitation had to be done because elements of the context may appear outside the context. For example:
/* if something happens, this function is called*/ or some_string = "if"
Tagging the branches from a preprocessor directive must take into account the backslash at the end of the line.
In order to identify the branches from preprocessor directive, there is a global variable which keeps track
whether or not a preprocessor directive is being traversed.
In order to identify if a string is being traversed, another global variable is used.


This is the finite state machine which identifies a context.
The starting state is OutContext. When the beginning of a comment or the words if, for while are found, the finite
state machine goes to the next state. When inside a multi-line comment-/**/-(InComment, InConditionInComment,
InConditionOpenPrenInComment), only finding the end of the comment will lead to leaving
that state.
In case there are multiple parenthesis inside a context, the last parenthesis is identified using a counter initialized
with value 1, which increments when an open parenthesis is encountered and decrements when a closing parenthesis is
encountered. Cases such as --if (c == ')')-- treated also.

                                         \n
                    +----------------------------------------------+
                    |                                              |   +----------------------------------------------+
                    |                                 +--------+   |   |                                              |
                    |                                 |        |   |   |                                              |
                    |                                 |     +--+---v---v-----------+                                  |
                    |                                 +---->+      OutContext      +<-----+                           |
               +----+---------+            //               +------+---------+-----+      |                           |
               |InLineComment +<-------------------------------+   |         |            |                           |
               +--------------+                                    |         |            |                           |
                                                                   +         |            | */                        |
             +-----+                                     if, for, while      |            |                           |
             |     |                                               +         | /*         |                           |
             |     |                                               |         |            |                           |
         +---+-----v-------+                                       |         |         +--+--------------------+      |
         |  InCondition    +<--------------------------------------+         +-------->+       InComment       |      |
         | count_paren = 1 |                                                           +---------+------^------+      |
         +-+----^------+---+                                                                     |      |             |
           |    |      |                                                                         |      |             |
           +    +      |            (                                                            +------+             |
           /*  */      +--------------------------+                                                                   |
           +    +                                 |                                                                   |
+----------v----+------+                          |                                                                   |
| InConditionInComment |                          |                                                                   |
+---+------^-----------+                          |     count_paren != 0                                              |
    |      |                                      |    +--+                                                           |
    |      |                                      |    |  |                                                           |
    |      |                             +--------v----+--v---+                                                       |
    +------+                             |InConditionOpenParen|                                                       |
                                         +-+----^---------+---+                                                       |
                                           |    |         |                                                           |
                                           |    |         |                                                           |
                                           |    |         |                                                           |
                                           +    +         |           )              +------------------------------+ |
                                           /*   */        +------------------------->+InConditionOpenParenCloseParen+-+
                                           +    +                                    +------------------------------+
                                           |    |
                             +-------------v----+----------+
                             |InConditionOpenParenInComment|
                             +-----+-----^-----------------+
                                   |     |
                                   |     |
                                   +-----+




In the case where inside the if, there are preprocessor directives, the context is not tagged. There are very
few cases like that. When another branch is found inside the current branch, the parenthesis counter is reset and the 
new context is considered.
Example :
#ifdef A
					if (a >= 0
#else
					if ((b > 0 && (a == 0 && b))
#endif
					&& c == 0)


Possible problems:
The parser was tested only on source files of PHP, Python and HHVM. It may not work on other projects which contain
corner cases which were not considered.

More details in the comments in the code.
