Prerequisite:
You must have python installed.

Contents:
- global_var.py
- tag_file.py
- apply_on_folder.py
- run_class.py
- states_imp.py
- fsm.py
- state.py
- helpers.py
- README

WHAT IT DOES?
branch_tagger takes .c and .h files from a folder and tags all the if, while, for branches with the comment
/*branch_type branch boolean_operator_type*/
branch_type = {if, for, while}
boolean_operator_type = {&&, ||}

If there are multiple conditions inside and if, for, while, branch_tagger will eliminate all line endings, then it will
split the line before the binary operator(&& or ||) and it will tag each condition until the last closing parenthesis
of the if, while, for.

Example: if /* multi-line
            comment */ (a && b || /* comment
                        inside branch*/ c) a = b
          -------->
          if /* multi-line             comment */ (a /*if branch &&*/
          && b /*if branch ||*/
          || /* comment                         inside branch*/ c) /*if branch &&*/a = b


USAGE:
The script will make a copy of the folder which contains the files you want to modify(a.k.a. the .c and .h files which
will have the if, for and while branches tagged) and it will replace the original ones with the tagged files.

The script will replace the original files with the files having the branches tagged. The original files are kept in
OriginalFolderCopy.


IMPLEMENTATION
A finite state machine handles the various states the source code from a .c or .h file traverses.
The area which will be tagged is called context. The context begins when an if, for, while is found and it ends when
the last closing parenthesis is found. Example of context: if (a && b)

OutContext represents the interior of a comment, a string or everything else which is not inside a context.
This delimitation had to be done because elements of the context may appear outside the context. For example:
/* if something happens, this function is called*/ or some_string = "if"
Tagging the branches from a preprocessor directive must take into account the backslash at the end of the line.
In order to identify the branches from preprocessor directive, there is a global variable which keeps track
whether or not a preprocessor directive is being traversed.
In order to identify if a string is being traversed, another global variable is used.


This is the finite state machine which identifies a context.
The starting state is OutContext. When the beginning of a comment or the words if, for while are found, the finite
state machine goes to the next state. When inside a multi-line comment-/**/-(InComment, InConditionInComment,
InConditionOpenPrenInComment), only finding the end of the comment will lead to leaving
that state. One line comments -//- are treated differently; the treatment is explained in helpers.py, in
function tokenize_line.
In case there are multiple parenthesis inside a context, the last parenthesis is identified using a counter initialized
with value 1, which increments when an open parenthesis is encountered and decrements when a closing parenthesis is
encountered. Cases where ')' or '(' are encountered are treated also.

                                                                       +----------------------------------------------+
                                                      +--------+       |                                              |
                                                      |        |       |                                              |
                                                      |     +--+-------v-----------+                                  |
                                                      +----->      OutContext      <------+                           |
                                                            +------+---------+-----+      |                           |
                                                                   |         |            |                           |
                                                                   |         |            |                           |
                                                                   +         |            | */                        |
             +-----+                                     if, for, while      |            |                           |
             |     |                                               |         | /*         |                           |
             |     |                                               |         |            |                           |
         +---+-----v-------+                                       |         |         +--+--------------------+      |
         |  InCondition    +<--------------------------------------+         +-------->+       InComment       |      |
         | count_paren = 1 |                                                           +---------+------^------+      |
         +-+----^------+---+                                                                     |      |             |
           |    |      |                                                                         |      |             |
           |    |      |            (                                                            +------+             |
           /*  */      +--------------------------+                                                                   |
           |    |                                 |                                                                   |
+----------v----+------+                          |                                                                   |
| InConditionInComment |                          |                                                                   |
+---+------^-----------+                          |     count_paren != 0                                              |
    |      |                                      |    +--+                                                           |
    |      |                                      |    |  |                                                           |
    |      |                             +--------v----+--v---+                                                       |
    +------+                             |InConditionOpenParen|                                                       |
                                         +-+----^---------+---+                                                       |
                                           |    |         |                                                           |
                                           |    |         |                                                           |
                                           |    |         |                                                           |
                                           |    |         |           )              +------------------------------+ |
                                           /*   */        +------------------------->+InConditionOpenParenCloseParen+-|
                                           |    |                                    +------------------------------+       
                                           |    |                                                                           
                             +-------------v----+----------+
                             |InConditionOpenParenInComment|
                             +-----+-----^-----------------+
                                   |     |                                                                                  
                                   |     |                                                                                  
                                   +-----+                                                                                  


In this case particular case, the context is tagged with /*weird condition*/. When another branch is found inside the
current branch, the counter is reset and the new context is considered.
Example :
#ifdef A
					if (a >= 0
#else
					if ((b > 0 && (a == 0 && b))
#endif
					&& c == 0)


Possible problems:
The parser was tested only on source files of PHP and Python. It may not work on other projects which contain corner
cases which were not considered.